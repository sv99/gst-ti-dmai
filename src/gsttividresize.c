/*
 * gsttividresize.c
 *
 * This file defines the "TIVidresize" element, which resizes the video frames
 * using hardware resizer (if available).
 *
 * Example usage:
 *     gst-launch videotestsrc ! TIVidresize ! fakesink silent=TRUE
 *
 * Original Author:
 *     Brijesh Singh, Texas Instruments, Inc.
 *
 * Note: Element pushes dmai transport buffer to the src. The downstream can 
 * use Dmai transport macro to get the DMAI buffer handle.
 *
 * This element supports only YUV422 and Y8C8 color space.
 *
 * Copyright (C) $year Texas Instruments Incorporated - http://www.ti.com/
 *
 * This program is free software; you can redistribute it and/or modify 
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation version 2.1 of the License.
 *
 * This program is distributed #as is# WITHOUT ANY WARRANTY of any kind,
 * whether express or implied; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif

#include <stdio.h>
#include <string.h>
#include <gst/gst.h>
#include <gst/video/video.h>
#include <gst/base/gstbasetransform.h>

#include <ti/sdo/dmai/Dmai.h>
#include <ti/sdo/dmai/Buffer.h>
#include <ti/sdo/dmai/BufferGfx.h>
#include <ti/sdo/dmai/BufTab.h>
#include <ti/sdo/dmai/Resize.h>

#include "gsttividresize.h"
#include "gsttidmaibuffertransport.h"

/* Declare variable used to categorize GST_LOG output */
GST_DEBUG_CATEGORY_STATIC (gst_tividresize_debug);
#define GST_CAT_DEFAULT gst_tividresize_debug

/* Element property identifier */
enum {
  PROP_0,
  PROP_CONTIG_INPUT_FRAME       /*  contiguousInputFrame    (boolean)   */
};

/* Define sink and src pad capabilities.  Currently, UYVY and Y8C8
 * supported.
 *
 * UYVY - YUV 422 interleaved corresponding to V4L2_PIX_FMT_UYVY in v4l2
 * Y8C8 - YUV 422 semi planar. The dm6467 VDCE outputs this format after a
 *        color conversion.The format consists of two planes: one with the
 *        Y component and one with the CbCr components interleaved (hence semi)  *        See the LSP VDCE documentation for a thorough description of this
 *        format.
 */
static GstStaticPadTemplate sink_factory = GST_STATIC_PAD_TEMPLATE(
    "sink",
    GST_PAD_SINK,
    GST_PAD_ALWAYS,
    GST_STATIC_CAPS
    ( GST_VIDEO_CAPS_YUV("UYVY")";"
      GST_VIDEO_CAPS_YUV("Y8C8")
    )
);

static GstStaticPadTemplate src_factory = GST_STATIC_PAD_TEMPLATE(
    "src",
    GST_PAD_SRC,
    GST_PAD_ALWAYS,
    GST_STATIC_CAPS
    ( GST_VIDEO_CAPS_YUV("UYVY")";"
      GST_VIDEO_CAPS_YUV("Y8C8")
    )
);

/* Declare a global pointer to our element base class */
static GstElementClass *parent_class = NULL;

/* Static Function Declarations */
static void
 gst_tividresize_base_init(gpointer g_class);
static void
 gst_tividresize_class_init(GstTIVidresizeClass *g_class);
static void
     gst_tividresize_init(GstTIVidresize *object);
static gboolean gst_tividresize_exit_resize(GstTIVidresize *vidresize);
static void gst_tividresize_fixate_caps (GstBaseTransform *trans,
     GstPadDirection direction, GstCaps *caps, GstCaps *othercaps);
static gboolean gst_tividresize_set_caps (GstBaseTransform *trans, 
    GstCaps *in, GstCaps *out);
static gboolean gst_tividresize_parse_caps (GstCaps *cap, gint *width,
    gint *height, guint32 *fourcc);
static GstCaps * gst_tividresize_transform_caps (GstBaseTransform *trans,
    GstPadDirection direction, GstCaps *caps);
static GstFlowReturn gst_tividresize_transform (GstBaseTransform *trans,
    GstBuffer *inBuf, GstBuffer *outBuf);
static gboolean gst_tividresize_get_unit_size (GstBaseTransform *trans,
    GstCaps *caps, guint *size);
ColorSpace_Type gst_tividresize_get_colorSpace (guint32 fourcc);
static gboolean gst_tividresize_calcSize (gint width, gint height, 
    ColorSpace_Type colorSpace, guint *size);
static void gst_tividresize_set_property(GObject *object, guint prop_id,
    const GValue *value, GParamSpec *pspec);
static gboolean gst_tividresize_execute_resizer (GstTIVidresize *vidresize,
    GstBuffer *inbuf, GstBuffer *outbuf);
static GstFlowReturn gst_tividresize_prepare_output_buffer (GstBaseTransform
    *trans, GstBuffer *inBuf, gint size, GstCaps *caps, GstBuffer **outBuf);

/******************************************************************************
 * gst_tividresize_init
 *****************************************************************************/
static void gst_tividresize_init (GstTIVidresize *vidresize)
{
    gst_base_transform_set_qos_enabled (GST_BASE_TRANSFORM (vidresize), TRUE);
}

/******************************************************************************
 * gst_tividresize_get_type
 *    Boiler-plate function auto-generated by "make_element" script.
 *    Defines function pointers for initialization routines for this element.
 ******************************************************************************/
GType gst_tividresize_get_type(void)
{
    static GType object_type = 0;

    if (G_UNLIKELY(object_type == 0)) {
        static const GTypeInfo object_info = {
            sizeof(GstTIVidresizeClass),
            gst_tividresize_base_init,
            NULL,
            (GClassInitFunc) gst_tividresize_class_init,
            NULL,
            NULL,
            sizeof(GstTIVidresize),
            0,
            (GInstanceInitFunc) gst_tividresize_init
        };

        object_type = g_type_register_static(GST_TYPE_BASE_TRANSFORM,
                          "GstTIVidresize", &object_info, (GTypeFlags)0);

        /* Initialize GST_LOG for this object */
        GST_DEBUG_CATEGORY_INIT(gst_tividresize_debug, "TIVidresize", 0,
            "TI Video Resize");

        GST_LOG("initialized get_type\n");
    }

    return object_type;
};

/******************************************************************************
 * gst_tividresize_base_init
 *    Boiler-plate function auto-generated by "make_element" script.
 *    Initializes element base class.
 ******************************************************************************/
static void gst_tividresize_base_init(gpointer gclass)
{
    static GstElementDetails element_details = {
        "TI video scale",
        "Filter/Resize",
        "Resize video using harware resizer",
        "Brijesh Singh; Texas Instruments, Inc."
    };

    GstElementClass *element_class = GST_ELEMENT_CLASS(gclass);

    gst_element_class_add_pad_template(element_class,
        gst_static_pad_template_get (&src_factory));
    gst_element_class_add_pad_template(element_class,
        gst_static_pad_template_get (&sink_factory));
    gst_element_class_set_details(element_class, &element_details);

    GST_LOG("initialized base init\n");
}

/******************************************************************************
 * gst_tividresize_class_init
 *    Boiler-plate function auto-generated by "make_element" script.
 *    Initializes the TIVidresize class.
 ******************************************************************************/
static void gst_tividresize_class_init(GstTIVidresizeClass *klass)
{
    GObjectClass    *gobject_class;
    GstBaseTransformClass   *trans_class;

    gobject_class    = (GObjectClass*)    klass;
    trans_class      = (GstBaseTransformClass *) klass;

    gobject_class->set_property = gst_tividresize_set_property;

    gobject_class->finalize = (GObjectFinalizeFunc)gst_tividresize_exit_resize;

    trans_class->transform_caps = 
        GST_DEBUG_FUNCPTR(gst_tividresize_transform_caps);
    trans_class->set_caps  = GST_DEBUG_FUNCPTR(gst_tividresize_set_caps);
    trans_class->transform = GST_DEBUG_FUNCPTR(gst_tividresize_transform);
    trans_class->fixate_caps = GST_DEBUG_FUNCPTR(gst_tividresize_fixate_caps);
    trans_class->get_unit_size = 
            GST_DEBUG_FUNCPTR(gst_tividresize_get_unit_size);
    trans_class->passthrough_on_same_caps = TRUE;
    trans_class->prepare_output_buffer = 
        GST_DEBUG_FUNCPTR(gst_tividresize_prepare_output_buffer);
    parent_class = g_type_class_peek_parent (klass);

    g_object_class_install_property(gobject_class, PROP_CONTIG_INPUT_FRAME,
        g_param_spec_boolean("contiguousInputFrame", "Contiguous input buffer",
            "Set this if element recieves contiguous input frame from"
            " upstream.", FALSE, G_PARAM_WRITABLE));

    GST_LOG("initialized class init\n");
}

/*****************************************************************************
 * gst_tividresize_prepare_output_buffer
 *    Function is used to allocate output buffer
 *****************************************************************************/
static GstFlowReturn gst_tividresize_prepare_output_buffer (GstBaseTransform
    *trans, GstBuffer *inBuf, gint size, GstCaps *caps, GstBuffer **outBuf)
{
    GstTIVidresize *vidresize = GST_TIVIDRESIZE(trans);
    Buffer_Handle   hOutBuf;

    if (vidresize->hResize == NULL) {
        return GST_FLOW_OK;
    }
     
    GST_LOG("begin prepare buffer\n");

    hOutBuf = BufTab_getFreeBuf(vidresize->hOutBufTab);
    
    if (hOutBuf == NULL) {
        GST_ERROR("failed to get free buffer\n");
        return GST_FLOW_ERROR;
    }

    /* Create a DMAI transport buffer object to carry a DMAI buffer to
     * the source pad.  The transport buffer knows how to release the
     * buffer for re-use in this element when the source pad calls
     * gst_buffer_unref().
     */
    *outBuf = gst_tidmaibuffertransport_new(hOutBuf, NULL);
    gst_buffer_set_data(*outBuf, (guint8*) Buffer_getUserPtr(hOutBuf), 
            Buffer_getSize(hOutBuf));
    gst_buffer_set_caps(*outBuf, GST_PAD_CAPS(trans->srcpad));

    GST_LOG("end prepare buffer\n");   
    return GST_FLOW_OK;
}

/******************************************************************************
 * gst_tividenc_set_property
 *     Set element properties when requested.
 ******************************************************************************/
static void gst_tividresize_set_property(GObject *object, guint prop_id,
                const GValue *value, GParamSpec *pspec)
{
    GstTIVidresize *vidresize = GST_TIVIDRESIZE(object);

    GST_LOG("begin set_property\n");

    switch (prop_id) {
        case PROP_CONTIG_INPUT_FRAME:
            vidresize->contiguousInputFrame = g_value_get_boolean(value);
            GST_LOG("setting \"contiguousInputFrame\" to \"%s\"\n",
                vidresize->contiguousInputFrame ? "TRUE" : "FALSE");
            break;
        default:
            G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
            break;
    }

    GST_LOG("end set_property\n");
}
       
/******************************************************************************
 * gst_tividresize_calcSize 
 *    Calculate the size based on resolution and colorspace.
 *****************************************************************************/
static gboolean gst_tividresize_calcSize (gint width, gint height, 
    ColorSpace_Type colorSpace, guint *size)
{
    gint             lineLength;
    
    GST_LOG("begin calcSize \n");

    lineLength = BufferGfx_calcLineLength(width, colorSpace);

    if (lineLength < 0) {
        *size = (guint) lineLength;
    }
    else if (colorSpace == ColorSpace_YUV422PSEMI) {
        *size = (guint) lineLength * height * 2;
    }
    else if (colorSpace == ColorSpace_YUV420PSEMI) {
        *size = (guint) lineLength * height * 3 / 2;
    }
    else {
        *size = (guint) lineLength * height;
    }

    GST_LOG("end calcSize\n");
    return TRUE;
}

/******************************************************************************
 * gst_tividresize_get_unit_size
 *   get the size in bytes of one unit for the given caps
 *****************************************************************************/ 
static gboolean gst_tividresize_get_unit_size (GstBaseTransform *trans,
    GstCaps *caps, guint *size)
{
    gint           height, width;
    guint32         fourcc;
    ColorSpace_Type colorSpace;

    GST_LOG("begin get_unit_size\n");
 
    if (!gst_tividresize_parse_caps(caps, &width, &height, &fourcc)) {
        GST_ERROR("Failed to get resolution\n");
        return FALSE;
    }

    colorSpace = gst_tividresize_get_colorSpace(fourcc);

    if (!gst_tividresize_calcSize(width, height, colorSpace, size)) {
        GST_ERROR("Failed to calculate output size\n");
        return FALSE;
    }
  
    GST_LOG("end get_unit_size\n"); 
    return TRUE; 
}

/******************************************************************************
 * gst_tividresize_execute_resizer
 *   Resize incoming buffer to outgoing buffer.
 *****************************************************************************/
static gboolean gst_tividresize_execute_resizer (GstTIVidresize *vidresize,
    GstBuffer *inBuf, GstBuffer *outBuf)
{
    Buffer_Handle   hDstBuf;
    BufferGfx_Attrs gfxAttrs   = BufferGfx_Attrs_DEFAULT;
   
    /* Get the output buffer pointer */
    hDstBuf = GST_TIDMAIBUFFERTRANSPORT_DMAIBUF(outBuf);

    /* Create input buffer */
    GST_LOG("creating input buffer\n");
    if (vidresize->hRszInBuf == NULL) {

        if (vidresize->contiguousInputFrame) {
            /* If element is configured to recieve contiguous input buffer 
             * then we will create reference buffer.
             */
            gfxAttrs.bAttrs.reference  = TRUE;
        }
        gfxAttrs.colorSpace     = vidresize->colorSpace;
        gfxAttrs.dim.width      = vidresize->srcWidth;
        gfxAttrs.dim.height     = vidresize->srcHeight;
        gfxAttrs.dim.lineLength = BufferGfx_calcLineLength(
                                  gfxAttrs.dim.width, gfxAttrs.colorSpace);
        vidresize->hRszInBuf = Buffer_create(GST_BUFFER_SIZE(inBuf), 
                                 BufferGfx_getBufferAttrs(&gfxAttrs));
        if (vidresize->hRszInBuf == NULL) {
            GST_ERROR("failed to create resizer input buffer\n");
            return FALSE;
        }
    }

    /* If element is configured to recieve contiguous input buffer then 
     * we do not need to copy the buffer in cmem memory.
     */
    if (vidresize->contiguousInputFrame) {
        BufferGfx_resetDimensions(vidresize->hRszInBuf);
        Buffer_setUserPtr(vidresize->hRszInBuf, (Int8*)GST_BUFFER_DATA(inBuf));
        Buffer_setNumBytesUsed(vidresize->hRszInBuf, GST_BUFFER_SIZE(inBuf));
    }
    else {
        /* Copy the input buffer in contiguous buffer */
        BufferGfx_resetDimensions(vidresize->hRszInBuf);
        memcpy(Buffer_getUserPtr(vidresize->hRszInBuf), 
            GST_BUFFER_DATA(inBuf), GST_BUFFER_SIZE(inBuf));
        Buffer_setNumBytesUsed(vidresize->hRszInBuf, GST_BUFFER_SIZE(inBuf));
    }

    /* Configure resizer */
    GST_LOG("configuring resize\n");
    if (Resize_config(vidresize->hResize, vidresize->hRszInBuf, hDstBuf) < 0) {
        GST_ERROR("failed to configure resize\n");
        return FALSE;
    }

    /* Execute resizer */
    GST_LOG("executing resizer\n");      
    if (Resize_execute(vidresize->hResize,vidresize->hRszInBuf, hDstBuf) < 0) {
        GST_ERROR("failed to execute resizer\n");
        return FALSE;
    }
    
    return TRUE;
}

/******************************************************************************
 * gst_tividresize_transform 
 *    Transforms one incoming buffer to one outgoing buffer.
 *****************************************************************************/
static GstFlowReturn gst_tividresize_transform (GstBaseTransform *trans,
    GstBuffer *inBuf, GstBuffer *outBuf)
{
    GstTIVidresize *vidresize = GST_TIVIDRESIZE(trans);

    GST_LOG("begin transform\n");

    /* Execute resizer on input buffer  */
    if (gst_tividresize_execute_resizer(vidresize, inBuf, outBuf) < 0) {
        GST_ERROR("failed to perform resizing on input buffer\n");
        return GST_FLOW_ERROR;
    }

    GST_LOG("end transform\n");

    return GST_FLOW_OK;
}

/******************************************************************************
 * gst_tividresize_transform_caps
 *   Given the pad in this direction and the given caps, what caps are allowed 
 *   on the other pad in this element
 *****************************************************************************/
static GstCaps * gst_tividresize_transform_caps (GstBaseTransform *trans,
    GstPadDirection direction, GstCaps *caps)
{
    GstTIVidresize      *vidresize;
    GstCaps             *ret;
    GstStructure        *structure;
    guint32             fourcc;

    g_return_val_if_fail(GST_CAPS_IS_SIMPLE(caps), NULL);

    vidresize   = GST_TIVIDRESIZE(trans);

    GST_LOG("begin transform caps (%s)\n",
        direction==GST_PAD_SRC ? "src" : "sink");

    structure   = gst_caps_get_structure(caps, 0);

    /* check if we support the format before copying the input caps */
    if (!gst_structure_has_name(structure, "video/x-raw-yuv")) {
        GST_ERROR("cap does not have video/x-raw-yuv string\n");
        goto not_implemented;
    }

    if (!gst_structure_get_fourcc(structure, "format", &fourcc)) {
        GST_ERROR("failed to get fourcc from cap\n");
        goto not_implemented;
    }

    if (fourcc != GST_MAKE_FOURCC('U', 'Y', 'V', 'Y') &&
            fourcc != GST_MAKE_FOURCC('Y', '8', 'C', '8')) {
        GST_ERROR("element does not support this fourcc\n");
        goto not_implemented;
    }

    ret = gst_caps_copy(caps);
    structure = gst_structure_copy (gst_caps_get_structure (ret, 0));

    gst_structure_set (structure,
      "width", GST_TYPE_INT_RANGE, 1, G_MAXINT,
      "height", GST_TYPE_INT_RANGE, 1, G_MAXINT, (gchar*) NULL);

    gst_caps_merge_structure (ret, gst_structure_copy (structure));

    gst_structure_free (structure);

    GST_LOG("end transform caps\n");

    return ret;

not_implemented:
    GST_ERROR("not implemented format\n");
    return gst_caps_new_empty();
}

/******************************************************************************
 * gst_tividresize_parse_caps
 *****************************************************************************/
static gboolean gst_tividresize_parse_caps (GstCaps *cap, gint *width,
    gint *height, guint32 *format)
{
    GstStructure    *structure;
    structure = gst_caps_get_structure(cap, 0);
    
    GST_LOG("begin parse caps\n");

    if (!gst_structure_get_int(structure, "width", width)) {
        GST_ERROR("Failed to get width \n");
        return FALSE;
    }

    if (!gst_structure_get_int(structure, "height", height)) {
        GST_ERROR("Failed to get height \n");
        return FALSE;
    }
    
    if (!gst_structure_get_fourcc(structure, "format", format)) {
        GST_ERROR("failed to get fourcc from cap\n");
    }

    GST_LOG("end parse caps\n");
   
    return TRUE; 
}

/*****************************************************************************
 * gst_tividresize_get_colorSpace
 ****************************************************************************/
ColorSpace_Type gst_tividresize_get_colorSpace (guint32 fourcc)
{
    switch (fourcc) {
        case GST_MAKE_FOURCC('U', 'Y', 'V', 'Y'):            
            return ColorSpace_UYVY;
        case GST_MAKE_FOURCC('Y', '8', 'C', '8'):
            return ColorSpace_YUV422PSEMI;
        default:
            GST_ERROR("failed to get colorspace\n");
            return ColorSpace_NOTSET;
    }
}

/******************************************************************************
 * gst_tividresize_set_caps
 *****************************************************************************/
static gboolean gst_tividresize_set_caps (GstBaseTransform *trans, 
    GstCaps *in, GstCaps *out)
{
    GstTIVidresize *vidresize = GST_TIVIDRESIZE(trans);
    BufferGfx_Attrs gfxAttrs = BufferGfx_Attrs_DEFAULT;
    guint32         fourcc;
    Resize_Attrs    rszAttrs  = Resize_Attrs_DEFAULT;
    guint           outBufSize;

    GST_LOG("begin set caps\n");

    /* parse input cap */
    if (!gst_tividresize_parse_caps(in, &vidresize->srcWidth,
             &vidresize->srcHeight, &fourcc)) {
        GST_ERROR("Failed to get input resolution\n");
        return FALSE;
    }

    /* parse output cap */
    if (!gst_tividresize_parse_caps(out, &vidresize->dstWidth,
             &vidresize->dstHeight, &fourcc)) {
        GST_ERROR("Failed to get output resolution\n");
        return FALSE;
    }

    /* map fourcc with its corresponding dmai colorspace type */
    vidresize->colorSpace           = gst_tividresize_get_colorSpace(fourcc);

    /* calculate output buffer size */
    gst_tividresize_calcSize(vidresize->dstWidth,vidresize->dstHeight, 
        vidresize->colorSpace, &outBufSize);

    /* Create output buffer */
    GST_LOG("creating output buffer\n");
    gfxAttrs.colorSpace = vidresize->colorSpace;
    gfxAttrs.dim.width  = vidresize->dstWidth;
    gfxAttrs.dim.height = vidresize->dstHeight;
    gfxAttrs.dim.lineLength = BufferGfx_calcLineLength(vidresize->dstWidth, 
                                vidresize->colorSpace);
    gfxAttrs.bAttrs.useMask = gst_tidmaibuffertransport_GST_FREE;
    vidresize->hOutBufTab = BufTab_create(4, outBufSize, 
                            BufferGfx_getBufferAttrs(&gfxAttrs));
    if (vidresize->hOutBufTab == NULL) {
        GST_ERROR("failed to allocate memory for output buffer\n");
        return GST_FLOW_ERROR;
    }

    vidresize->hRszInBuf            = NULL;
    vidresize->hResize              = NULL;

    if (vidresize->contiguousInputFrame != TRUE) {
        vidresize->contiguousInputFrame = FALSE;
    }

    GST_LOG("Resize from=%dx%d -> to=%dx%d\n", vidresize->srcWidth, 
        vidresize->srcHeight, vidresize->dstWidth, vidresize->dstHeight);

    /* Open resize module */
    GST_LOG("creating resize module\n");
    vidresize->hResize = Resize_create(&rszAttrs);

    if (vidresize->hResize == NULL) {
        GST_ERROR("failed to open resize module\n");
        return FALSE;
    }

    GST_LOG("end set caps\n");
    return TRUE;
}

/******************************************************************************
 * gst_video_scale_fixate_caps 
 *****************************************************************************/
static void gst_tividresize_fixate_caps (GstBaseTransform *trans,
     GstPadDirection direction, GstCaps *caps, GstCaps *othercaps)
{
    GstStructure    *ins, *outs;
    gint            srcWidth, srcHeight;
    gint            dstWidth, dstHeight;

    g_return_if_fail(gst_caps_is_fixed(caps));

    GST_LOG("begin fixating cap\n");

    ins = gst_caps_get_structure(caps, 0);
    outs = gst_caps_get_structure(othercaps, 0);

    /* get the sink dimension */
    if (!gst_structure_get_int(ins, "width", &srcWidth)) {
        if (gst_structure_get_int(ins, "height", &srcHeight)) {
            GST_LOG("dimensions already set to %dx%d, not fixating", 
                    srcWidth, srcHeight);
        }
        return;
    }

    /* get the source dimension */
    if (gst_structure_get_int(outs, "width", &dstWidth)) {
        if (gst_structure_get_int(outs, "height", &dstHeight)) {
            GST_LOG("dimensions already set to %dx%d, not fixating", 
                    srcWidth, dstHeight);
        }
        return;
    }

    GST_LOG("end fixating cap\n");
}

/******************************************************************************
 * gst_tividresize_exit_resize
 *    Shut down any running video resizer, and reset the element state.
 ******************************************************************************/
static gboolean gst_tividresize_exit_resize(GstTIVidresize *vidresize)
{
    GST_LOG("begin exit_video\n");

    /* Shut down remaining items */
    if (vidresize->hResize) {
        GST_LOG("deleting resizer device\n");
        Resize_delete(vidresize->hResize);
        vidresize->hResize = NULL;
    }

    if (vidresize->hRszInBuf) {
        GST_LOG("freeing resizer outbuf buffer\n");
        BufTab_delete(vidresize->hOutBufTab);
        vidresize->hRszInBuf = NULL;
    }
    
    GST_LOG("end exit_video\n");
    return TRUE;
}

/******************************************************************************
 * Custom ViM Settings for editing this file
 ******************************************************************************/
#if 0
 Tabs (use 4 spaces for indentation)
 vim:set tabstop=4:      /* Use 4 spaces for tabs          */
 vim:set shiftwidth=4:   /* Use 4 spaces for >> operations */
 vim:set expandtab:      /* Expand tabs into white spaces  */
#endif
